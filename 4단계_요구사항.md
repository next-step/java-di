# 🚀 4단계 - @Configuration 구현하기(힌트)

### **설정 파일을 읽어 Bean 등록 기능 추가**

- 다음과 같은 단위 테스트 코드 만들어 pass하도록 구현한다.

```java
public class ConfigurationBeanScannerTest {
    @Test
    public void register_simple() {
        BeanFactory beanFactory = new BeanFactory();
        ConfigurationBeanScanner cbs = new ConfigurationBeanScanner(beanFactory);
        cbs.register(ExampleConfig.class);
        beanFactory.initialize();

        assertNotNull(beanFactory.getBean(DataSource.class));
    }
}

```

- 위 테스트 코드에서 사용한 ExampleConfig는 다음과 같다.

```java
@Configuration
public class ExampleConfig {
    @Bean
    public DataSource dataSource() {
        final var jdbcDataSource = new JdbcDataSource();
        jdbcDataSource.setUrl("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;");
        jdbcDataSource.setUser("");
        jdbcDataSource.setPassword("");
        return jdbcDataSource;
    }
}

```

### **설정 파일을 통해 등록한 Bean과 ClasspathBeanScanner를 통해 추가한 Bean 통합**

- DI 1단계에서 구현한 BeanSanner를 ClasspathBeanSacnner로 변경하고 설정 파일로 등록한 Bean과 통합한다.
- 각 Scanner를 통해 생성한 Bean 간에도 의존관계를 가져야하기 때문에 BeanFactory를 각 Scanner에 전달하는 방식으로 다음과 같은 테스트 코드를 추가해 구현한다.

```java
public class ConfigurationBeanScannerTest {
    @Test
    public void register_classpathBeanScanner_통합() {
        BeanFactory beanFactory = new BeanFactory();
        ConfigurationBeanScanner cbs = new ConfigurationBeanScanner(beanFactory);
        cbs.register(IntegrationConfig.class);

        ClasspathBeanScanner cbds = new ClasspathBeanScanner(beanFactory);
        cbds.doScan("samples");
        beanFactory.initialize();

        assertNotNull(beanFactory.getBean(DataSource.class));

        JdbcSampleRepository sampleRepository = beanFactory.getBean(JdbcSampleRepository.class);
        assertNotNull(sampleRepository);
        assertNotNull(sampleRepository.getDataSource());

        JdbcTemplate jdbcTemplate = beanFactory.getBean(JdbcTemplate.class);
        assertNotNull(jdbcTemplate);
        assertNotNull(jdbcTemplate.getDataSource());
    }
}

```

- 위 테스트 코드에서 사용한 IntegrationConfig는 다음과 같다.

```java
@Configuration
public class IntegrationConfig {
    @Bean
    public DataSource dataSource() {
        final var jdbcDataSource = new JdbcDataSource();
        jdbcDataSource.setUrl("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;");
        jdbcDataSource.setUser("");
        jdbcDataSource.setPassword("");
        return jdbcDataSource;
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}

```

### **ConfigurationBeanScanner와 ClasspathBeanScanner을 통합하는 클래스 추가**

- ConfigurationBeanScanner와 ClasspathBeanScanner을 매번 수동으로 통합하는 것보다는 둘의 통합을 담당하는 새로운 클래스를 ApplicationContext라는 이름으로 추가한다.
- ApplicationContext에서는 설정 파일을 전달 받은 후 @ComponentScan 애노테이션의 경로 정보를 가져와 ClasspathBeanScanner을 초기화 하고, 설정 파일의 @Bean 정보를 바탕으로 ConfigurationBeanScanner을 초기화하는 역할을 담당한다.
- 다음과 같이 ApplicationContext를 초기화한 후 AnnotationHandlerMapping에서 ApplicationContext을 사용해 초기화가 가능하도록 통합할 수 있다.
```java
ApplicationContext ac = new ApplicationContext(MyConfiguration.class);
AnnotationHandlerMapping ahm = new AnnotationHandlerMapping(ac);
ahm.initialize();
```

---
### 요구사항 정리

[x] 설정파일을 읽어 빈을 등록하는 기능을 추가한다
[x] 각 Scanner를 통해 생성한 Bean 간에도 의존관계를 가져야하기 때문에 BeanFactory를 각 Scanner에 전달하는 방식으로 다음과 같은 테스트 코드를 추가해 구현한다.
[x] ConfigurationBeanScanner와 ClasspathBeanScanner을 통합하는 클래스 추가